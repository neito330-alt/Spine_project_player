こんにちは、いつも大変お世話になっております。


現在の表示順序のキーシステムはあらゆる変更を一つのキーとして登録するため、それにより上記のフォーラム挙げられているようなトラブルが時々発生します。
また、上がり下がりの判定がシステムに依存しており、上にドラッグしても入れ替え先のスロットが下がったと表示されてしまうことなどがあります。
こちらはその場では気になりませんが、後から見返した際に加えられた変更を認識しにくくしてしまいます。

それに伴う弊害として、補完によるスロットの動きが予想と異なるといった事態が発生します。
次のような事例を用意しました。こちらは三つのスロットを何度か移動し、アニメーションキーを登録した後にスロットを複製してどういった補完が行われたかを示したものです。(beta4.3で検証)

こちらを見ればわかりますが、スロットの動きを予測するのは非常に困難です。
こういった不明瞭な動作は予期せぬミスの原因になります。
そこでこの問題を解決するためにアイデアを考えました。




私が提案するのはオーダーオブジェクト(仮)と新しい表示順序キーの実装です

現在のバージョンだと表示順の変更は「表示順序」が単一のキーで管理しています。
*オブジェクトとしての表示順序であることを示すため括弧をつけています。
これをオーダーオブジェクトとスロットに2種類のキーで管理させるようにします。

まず、オーダーオブジェクトは「表示順序」内に作成することができ、設定ビューではフォルダと同様に振る舞い、スロットや他のオーダーオブジェクトを子にする事が可能です。
また、「表示順序」自体がオーダーオブジェクトとしての役割を持ちます。これはrootボーンをイメージするとわかりやすいです。

次にアニメーションキーについてです。
新たにオーダーオブジェクト間の移動を記録するキーを実装します。(以降は親変更キーと表現します)
キーの値は移動先のオーダーオブジェクトです。

そしてスロットはこの親変更キーを、オーダーオブジェクトは親変更キーと既存の表示順変更キーをドープシートにプロットする事ができます。




では、詳細な振る舞いについて説明します。

この図がデフォルトの状態です。
OrderObj_nはオーダーオブジェクトを表しており、それぞれ二つのスロットが入っています。
そしてアニメーションビューで変更を行った時のツリーとドープシートの動作を示したのが次の図です。

3つのシチュエーションを想定しています。
*これらは独立しています。("デフォルト→上,中,下"であり"デフォルト→上→中→下"ではありません)

上の例ではOrderObj_B内のSlot5をOrderObj_Aの最下層に移動しています。
Slot5は親がOrderObj_BからOrderObj_Aに変わったため親変更キーをプロットします。
また、OrderObj_A,Bは子に変更が起きたため表示順変更キーをプロットします。

真ん中の例ではOrderObj_BをOrderObj_Aの上に移動しています。
同じ階層内での移動は親が記録するためOrderObj_Bはキーをプロットせず、「表示順序」のキーになります。

下の例ではOrderObj_BをOrderObj_Aの子にしています。
こちらも上記の二つの例と同様に移動前、移動後の親と移動したオブジェクトのキーをプロットします。




オーダーオブジェクトを使えば、上記のフォーラムのような事例に対してもスマートな解決方法を提供することができます。
具体的には剣と盾のスロットをオーダーオブジェクトに入れておくことで、他の表示順変更の影響を受けず、影響を及ぼしません。
補間に関して直接的な変更は加えていませんが、影響が起こり得る範囲を制限することで間接的に対応しています。

さらに、beta4.3で追加されたスライダーコンストレイントで表示順を合成できるようになります。

また、仕組みが簡潔で比較的理解しやすく、オーダーオブジェクトを使用しなければ従来通りに使えるためデメリットもありません。
適切に扱えばタイムラインが増えすぎるといった事態も避けられます。


スライダーで合成した際などに表示順変更キーで登録されている子と実際の子が異なる場合や、親変更時に親の表示順変更キーを削除した場合などの例外が想定されますが、これらの問題は十分対処可能だと考えます。


今後表示順序に関するアップデートを計画する際の参考にしていただければ幸いです。